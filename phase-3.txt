/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       Phase I - None
*       Phase II -
*           CardTable extends JFrame, GUICard, Card, Hand, Deck
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/


package assignment5;

import javax.swing.Icon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JButton;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import javax.swing.JOptionPane;

public class Assignment5
{
    static CardTable myCardTable; //Panels for cards
    static int NUM_CARDS_PER_HAND = 7; //hand size for this game
    static int NUM_PLAYERS = 2; //person v. computer
    static JLabel[] computerLabels = new JLabel[NUM_CARDS_PER_HAND]; //computers cards
    static JLabel[] humanLabels = new JLabel[NUM_CARDS_PER_HAND]; //humans cards
    static JLabel[] playedCardLabels = new JLabel[NUM_PLAYERS]; //dealt cards
    static JLabel[] playLabelText = new JLabel[NUM_PLAYERS]; //middle text
    static CardGameFramework highCardGame; //game framework
    static boolean gameInPlay = false;
    static int roundsPlayed = 0;
    static Hand[] playerPlays = new Hand[NUM_PLAYERS];
    
    public static void main(String[] args)
    {
        //loads all card icons of full deck
        GUICard.loadCardIcons();
        
        // Create CardGameFramework
        int numPacksPerDeck = 1;
        int numJokersPerPack = 0;
        int numUnusedCardsPerPack = 0;
        Card[] unusedCardsPerPack = null;
        
        highCardGame = new CardGameFramework(numPacksPerDeck,
                numJokersPerPack, numUnusedCardsPerPack, unusedCardsPerPack, 
                NUM_PLAYERS, NUM_CARDS_PER_HAND);
        
        highCardGame.deal();
        
        //sets the panels for GUI
        myCardTable
                = new CardTable("CardTable", NUM_CARDS_PER_HAND, NUM_PLAYERS);
        myCardTable.setSize(800, 600);
        myCardTable.setLocationRelativeTo(null);
        myCardTable.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        myCardTable.setVisible(true);
        
        //dialog box to confirm playing game
        int playOrNot = JOptionPane.showConfirmDialog(null, "Ready to play War?", "", JOptionPane.YES_NO_OPTION);
        if (playOrNot == JOptionPane.YES_OPTION)
        {
            buildPanels();
        }  
    }
    
    //function to build panels, insert card icons and add click listeners
    public static void buildPanels()
    {
        int k;
        Icon tempIcon;
        
        CardClickListener clickListener = new CardClickListener();
        
        //inserts icons into player and human card panels
        for (k = 0; k < NUM_CARDS_PER_HAND; k++)
        {
            computerLabels[k] = new JLabel( GUICard.getBackCardIcon());
            if (highCardGame.getHand(1).inspectCard(k) == null)
                tempIcon = GUICard.getBlankIcon();
            else
                tempIcon = GUICard.getIcon(highCardGame.getHand(1).inspectCard(k));
            humanLabels[k] = new JLabel( tempIcon );
            humanLabels[k].addMouseListener(clickListener);   
        }

        //inserts cards into middle section
        for (k = 0; k < NUM_PLAYERS; k++)
        {
            playedCardLabels[k] = new JLabel( GUICard.getBlankIcon(),
                    JLabel.CENTER );
            if ( k % NUM_PLAYERS == 0 )
            {
                playLabelText[k] = new JLabel( "Computer", JLabel.CENTER );
            }
            else
            {
                String temp = "Player " + k;
                playLabelText[k] = new JLabel( temp, JLabel.CENTER );
            }
            playerPlays[k] = new Hand();
        }

        // ADD LABELS TO PANELS -----------------------------------------
        for (k = 0; k < NUM_CARDS_PER_HAND; k++)
        {
            myCardTable.pnlComputerHand.add(computerLabels[k]);
            myCardTable.pnlHumanHand.add(humanLabels[k]);
        }
        
        for (k = 0; k < NUM_PLAYERS; k++)
            myCardTable.pnlPlayArea.add(playedCardLabels[k]);
        for (k = 0; k < NUM_PLAYERS; k++)
            myCardTable.pnlPlayArea.add(playLabelText[k]);
        myCardTable.setVisible(true);
        myCardTable.repaint();
        
    }
    
    //removes card from icons after card is dealt
    public static void removeCard( JLabel[] labels, int removed )
    {
        for (int i = removed; i < labels.length; i++)
        {
            if (i == labels.length-1)
            {
                labels[i] = new JLabel(GUICard.getBlankIcon());
            }
            else
            {
                labels[i] = labels[i+1];
            }            
        }
    }
    
    //updates panels after card is dealt
    public static void updatePanels()
    {
        myCardTable.pnlComputerHand.removeAll();
        myCardTable.pnlHumanHand.removeAll();
        for (int i = 0; i < NUM_CARDS_PER_HAND; i ++)
        {
            myCardTable.pnlComputerHand.add(computerLabels[i]);
            myCardTable.pnlHumanHand.add(humanLabels[i]);
        }
        
        myCardTable.pnlComputerHand.revalidate();
        myCardTable.pnlHumanHand.revalidate();
    }
    
    //clickListener to listen for click on any card icon
    //implements MouseListener
    public static class CardClickListener implements MouseListener
    {
        Card humanCard;
        Card computerCard;
        
        //if mouse is clicked, card is considered dealt
        //computer now plays a card of its own
        //function flow control determines which label has been clicked
        public void mouseClicked(MouseEvent event)
        {
            if (event.getSource() == humanLabels[0])
            {
                humanCard = highCardGame.playCard(1, 0);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 0);
                removeCard(computerLabels, 0);
                updatePanels();
                //System.out.println(" Card 0 ");
                
            }
            else if (event.getSource() == humanLabels[1])
            {
                humanCard = highCardGame.playCard(1, 1);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 1);
                removeCard(computerLabels, 0);
                updatePanels();
            }
            else if (event.getSource() == humanLabels[2])
            {
                humanCard = highCardGame.playCard(1, 2);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 2);
                removeCard(computerLabels, 0);
                updatePanels();
            }
            else if (event.getSource() == humanLabels[3])
            {
                humanCard = highCardGame.playCard(1, 3);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 3);
                removeCard(computerLabels, 0);
                updatePanels();
            }
            else if (event.getSource() == humanLabels[4])
            {
                humanCard = highCardGame.playCard(1, 4);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 4);
                removeCard(computerLabels, 0);
                updatePanels();
            }
            else if (event.getSource() == humanLabels[5])
            {
                humanCard = highCardGame.playCard(1, 6);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 5);
                removeCard(computerLabels, 0);
                updatePanels();
            }
            else if (event.getSource() == humanLabels[6])
            {
                humanCard = highCardGame.playCard(1, 6);
                computerCard = highCardGame.playCard(0, computersPlay(highCardGame.getHand(0)));
                removeCard(humanLabels, 6);
                removeCard(computerLabels, 0);
                updatePanels();
            }
            
            myCardTable.pnlPlayArea.removeAll();
            playedCardLabels[0] = new JLabel(GUICard.getIcon(computerCard));
            playedCardLabels[1] = new JLabel(GUICard.getIcon(humanCard));
            myCardTable.pnlPlayArea.add(playedCardLabels[0]);
            myCardTable.pnlPlayArea.add(playedCardLabels[1]);
            myCardTable.pnlPlayArea.add(playLabelText[0]);
            myCardTable.pnlPlayArea.add(playLabelText[1]);
            myCardTable.pnlPlayArea.revalidate();
            
            //determines winner of round based on value of cards dealt
            //adds cards to the winner's array
            if (Card.valueAsInt(computerCard) > Card.valueAsInt(humanCard))
            {
                JOptionPane.showMessageDialog(null, ("Computer Wins Round!"));
                playerPlays[0].takeCard(computerCard);
                playerPlays[0].takeCard(humanCard);
            }
            else if (Card.valueAsInt(computerCard) == Card.valueAsInt(humanCard))
            {
                JOptionPane.showMessageDialog(null, ("Its a Draw No One Wins Round!"));
            }
            else 
            {
                JOptionPane.showMessageDialog(null, ("Player 1 Wins Round!"));
                playerPlays[1].takeCard(computerCard);
                playerPlays[1].takeCard(humanCard);
            }
            roundsPlayed++;
            
            if (roundsPlayed == NUM_CARDS_PER_HAND)
            {
                if (playerPlays[0].getNumCards() > playerPlays[1].getNumCards())
                    JOptionPane.showMessageDialog(null, ("Computer Wins Game!\nThanks for Playing"));
                else if (playerPlays[0].getNumCards() > playerPlays[1].getNumCards())
                    JOptionPane.showMessageDialog(null, ("Tie Game!\nThanks for Playing"));
                else
                    JOptionPane.showMessageDialog(null, ("Player 1 Wins Game!\nThanks for Playing"));
            }
        }

        public void mousePressed(MouseEvent e){}

        public void mouseReleased(MouseEvent e){}
        
        public void mouseEntered(MouseEvent e){}
        
        public void mouseExited(MouseEvent e){}
    }
    
    //algorithm to determine which card the computer plays
    public static int computersPlay(Hand hand)
    {
        hand.sortByVal();//sorts hand lowest to highest
        
        int numCards = hand.getNumCards(); 
        int middleCard = (numCards - 1) / 2; //middle index of hand
        
        //if there are two remaining cards, returns the lowest
        //if one remaining card, returns it.
        if(numCards == 1 || numCards == 2)
            return 0;
        if(numCards == 0)
            return -1;
        
        return middleCard;  
    }
    
}




/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       None
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/


package assignment5;

import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JFrame;
import javax.swing.JPanel;

//CardTable class creates creates a JFrame with three panels for:
// user, computer and dealt cards
public class CardTable extends JFrame
{
    static int MAX_CARDS_PER_HAND = 56;
    static int MAX_PLAYERS = 2;  // for now, we only allow 2 person games

    private int numCardsPerHand;
    private int numPlayers;

    public JPanel pnlComputerHand, pnlHumanHand, pnlPlayArea;

    //parameterized constructor that accepts title, numCardsPerHand, and players
    //calls super constructor from JFrame class
    public CardTable(String title, int numCardsPerHand, int numPlayers)
    {
        super(title);
        if (numCardsPerHand <= MAX_CARDS_PER_HAND)
            this.numCardsPerHand = numCardsPerHand;
        if (numPlayers <= MAX_PLAYERS)
            this.numPlayers = numPlayers;
        
        frameInit();
        this.setLayout( new GridLayout(3, 1) ); //Grid Layout of 3,1 to fit 3 panels
        
        pnlComputerHand = new JPanel( new GridLayout( 1, numCardsPerHand ) );
        pnlPlayArea = new JPanel( new GridLayout( 2, 2 ) );
        pnlHumanHand = new JPanel( new GridLayout( 1, numCardsPerHand ) );
        
        this.add( pnlComputerHand );
        this.add( pnlPlayArea );
        this.add( pnlHumanHand );
    }
    
    //accessor for numCardsPerHand
    public int getNumCardsPerHand()
    {
        return this.numCardsPerHand;
    }
    
    //accessor for numPlayers
    public int getNumPlayers()
    {
        return this.numPlayers;
    }
    
}




/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       None
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/


package assignment5;

import java.awt.Component;
import java.awt.Graphics;
import java.util.Arrays;
import javax.swing.Icon;
import javax.swing.ImageIcon;


//GUICard class loads the icons from the images source directory.
public class GUICard
{
    private static Icon[][] iconCards = new ImageIcon[14][4]; // 14 = A thru K + joker
    private static Icon iconBack; //generic backCard for hidden Cards
    private static Icon blankIcon; //generic blankCard for empty spots in hand
    static boolean iconsLoaded = false; //flag to notify if iconCards has already been loaded
    
    static void loadCardIcons()
    {
        // build the file names ("AC.gif", "2C.gif", "3C.gif", "TC.gif", etc.)
        // in a SHORT loop.  For each file name, read it in and use it to
        // instantiate each of the 57 Icons in the icon[] array.
        if (!iconsLoaded)
        {
            int count = 0;
            for (int j = 0; j < 4; j++)
            {
                for (int i = 0; i < 14; i++)
                {
                    String file = "images/" + turnIntIntoCardValue(i) +
                            turnIntIntoCardSuit(j) + ".gif";
                    iconCards[i][j] = new ImageIcon(file);
                }
            }
            iconBack = new ImageIcon("images/BK.gif");
            blankIcon = new ImageIcon("images/BL.gif");
            iconsLoaded = true;
        }
    }

    // turns 0 - 14 into "A", "2", "3", ... "Q", "K", "X"
    static String turnIntIntoCardValue(int k)
    {
        String[] cardValues = { "A", "2", "3", "4", "5", "6", "7", "8",
            "9", "T", "J", "Q", "K", "X" };
        if (k >=0 && k<= 13)
        {
            return cardValues[k];
        }
        return "";
    }

    // turns 0 - 3 into "C", "D", "H", "S"
    static String turnIntIntoCardSuit(int j)
    {
        String[] suites = { "C", "D", "H", "S" };
        if (j >=0 && j<= 3)
        {
            return suites[j];
        }
        return "";
    }
    
    //returns a specific Icon for a desired card
    static public Icon getIcon(Card card)
    {        
        return iconCards[Card.valueAsInt(card)][Card.suitAsInt(card)];
    }
    
    //returns iconBack card
    static public Icon getBackCardIcon()
    {
        return iconBack;
    }
    
    //returns iconBlank card
    static public Icon getBlankIcon()
    {
        return blankIcon;
    }
    
}





/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       None
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/


package assignment5;

import java.util.Arrays;

public class Card
{
    // Suit enum of possible suits for cards

    public enum Suit
    {
        clubs, diamonds, hearts, spades;
    }
    
    public static char[]valuRanks = { 'A', '2', '3', '4', '5', '6', '7', '8',
        '9', 'T', 'J', 'Q', 'K', 'X' };

    // private data members
    private char value;
    private Suit suit;
    private boolean errorFlag;

    // default constructor
    public Card()
    {
        set('A', Suit.spades);
    }

    // overloaded constructor that accepts a value and suit
    // calls on set() method to set the values
    public Card(char value, Suit suit)
    {
        set(Character.toUpperCase(value), suit);
    }

    // if no errors, returns a string with the card value and suit
    // if errorFlag is true, returns an error message
    public String toString()
    {
        if (errorFlag == true)
        {
            return "[Invalid card]";
        }
        return value + " of " + suit;
    }

    // sets the values of the card
    // uses private method isValid() to determine if values are appropriate
    // then sets errorFlag based on return of isValid()
    public boolean set(char value, Suit suit)
    {
        if (isValid(value, suit))
        {
            this.value = value;
            this.suit = suit;
            errorFlag = false;
            return true;
        }
        errorFlag = true;
        return false;
    }

    // accessor for errorFlag
    public boolean getErrorFlag()
    {
        return errorFlag;
    }

    // accessor for suit
    public Suit getSuit()
    {
        return suit;
    }

    // accessor for value 
    public char getValue()
    {
        return value;
    }

    // compares this object to another card. Determines if they are equal
    // based on value and suit
    public boolean equals(Card card)
    {
        if (value == card.value && suit == card.suit)
        {
            return true;
        }
        return false;
    }

    // private method to validate data
    // only checks for validity of value
    private boolean isValid(char value, Suit suit)
    {
        if ((value >= '2' && value <= '9')
                || value == 'A' || value == 'T'
                || value == 'J' || value == 'Q'
                || value == 'K' || value == 'X')
        {
            return true;
        }
        return false;
    }
    
    //sorts array based on suit and then value
    //bubble sort
    public static void arraySort( Card cards[], int arraySize )
    {
        Card temp;
        boolean sort = true;
        while (sort)
        {            
            sort = false;
            for ( int i = 0; i < arraySize-1; i++ )
            {
                if ( suitAsInt(cards[i]) > suitAsInt(cards[i+1]) )
                {
                    swapCards(cards, i, i+1);
                    sort = true;
                }
                else if ( suitAsInt(cards[i]) == suitAsInt(cards[i+1]) )
                {
                    if ( valueAsInt(cards[i]) > valueAsInt(cards[i+1]) )
                    {
                        swapCards(cards, i, i+1);
                        sort = true;
                    }
                }
            }
        }
    }
    
    //returns the values from 'A' to 'K' as an int
    //'A' is lowest, followed by '2', '3'...'K'
    public static int valueAsInt(Card card)
    {
        char testValue = card.value;
        switch ((char)testValue)
        {
            case 'A':
                return 0;
            case '2':
                return 1;
            case '3':
                return 2;
            case '4':
                return 3;
            case '5':
                return 4;
            case '6':
                return 5;
            case '7':
                return 6;
            case '8':
                return 7;
            case '9':
                return 8;
            case 'T':
                return 9;
            case 'J':
                return 10;
            case 'Q':
                return 11;
            case 'K':
                return 12;
            default:
                return 13;
        }
    }
    
    //returns suit as an int from 0-3
    public static int suitAsInt(Card card)
    {
        if (card.suit == Suit.clubs)
            return 0;
        else if (card.suit == Suit.diamonds)
            return 1;
        else if (card.suit == Suit.hearts)
            return 2;
        else 
            return 3;
    }
    
    //helper method for sort() to swap cards
    private static void swapCards( Card[] cards, int one, int two )
    {
        Card temp = cards[one];
        cards[one] = cards[two];
        cards[two] = temp;
    }
    
    //sorts only by value and ignores suit
    public static void arraySortByValue(Card cards[], int arraySize)
    {
        Card temp;
        boolean sort = true;
        while(sort)
        {
            sort = false;
            for(int i = 0; i < arraySize - 1; i++)
            {
               if ( valueAsInt(cards[i]) > valueAsInt(cards[i+1]) )
               {
                    swapCards(cards, i, i+1);
                    sort = true;
               } 
            }
        }
    }
}




/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       None
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/


package assignment5;

public class Hand
{
    //data members
    public static int MAX_CARDS = 50;
    private Card[] myCards;
    private int numCards;

    // Default Constructor
    public Hand()
    {
        myCards = new Card[MAX_CARDS];
        numCards = 0;
    }

    // Method that removes all cards from the Hand[] array
    public void resetHand()
    {
        myCards = new Card[MAX_CARDS];
        numCards = 0;
    }

    // This method adds cards to the next available position
    public boolean takeCard(Card card)
    {
        if (numCards >= MAX_CARDS)
        {
            return false;
        }
        else
        {
            myCards[numCards++] = new Card(card.getValue(), card.getSuit());
            return true;
        }
    }

    // This method returns and removes the card in the top position of the array
    public Card playCard()
    {
        Card card = myCards[numCards - 1];
        myCards[--numCards] = null;
        return card;
    }
    
    public Card playCard(int cardIndex)
    {
        Card card = myCards[cardIndex];
        for(int i = cardIndex; i < numCards - 1; i++)
            myCards[i] = myCards[i + 1];
        myCards[--numCards] = null;
        return card; 
    }

    // This method is a stringizer that is used prior to displaying the entire hand
    public String toString()
    {
        String str = "Hand = ( ";
        if (numCards == 0)
        {
            str += "empty hand )";
        }
        else
        {
            for (int i = 0; i < numCards - 1; i++)
            {
                str += myCards[i] + ", ";
            }
            str += myCards[numCards - 1] + " )";
        }
        return str;
    }

    // Getter for numCards
    public int getNumCards()
    {
        return numCards;
    }

    // Accessor to inspect an individual card, returns erroFlag = true if k is bad
    public Card inspectCard(int k)
    {
        Card card;
        if (k >= numCards)
        {
            card = null;//new Card('T', Card.Suit.spades);
        }
        else
        {
            card = myCards[k];
        }
        return card;
    }
    
    //sort method that sorts by suit and then value
    //calls Card arraySort() method
    public void sort()
    {
        if ( this.getNumCards() != 0 )
            Card.arraySort(myCards, numCards);
    }
    
    //sort method that sorts hand by value only
    //calls Card's sortByValue() method
    public void sortByVal()
    {
        if( this.getNumCards() != 0 )
            Card.arraySortByValue(myCards, numCards);
    }
}




/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       None
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/


package assignment5;

import java.util.Random;

public class Deck
{
    public final int MAX_CARDS = 336; // max 6 decks of 56 cards

    //private data members
    private static Card[] masterPack;
    private Card[] cards;

    int topCard;
    int numPacks;

    // A constructor that populates the arrays and assigns initial values to
    // members with the assistance of init()
    // Defaults to one pack of cards in the deck.
    public Deck()
    {
        init(1);
    }

    // A constructor that populates the arrays and assigns initial values to
    // members with the assistance of init(). This constructor is an overload
    // of the default constructor allowing for an parameter being set with the 
    // number of packs the deck will contain.
    // Takes one parameter, an int numPacks, that is used to to create a deck
    // of cards that is a combination of more than one pack
    public Deck(int numPacks)
    {
        init(numPacks);
    }

    // This public method initializes a deck of card according to the parameter
    // numPacks which is passed to it. This method calls on private method
    // allocateMasterPack() which sets the static array with 52 cards used to 
    // create each pack that is added to the Deck.
    // Here the private members numPacks and topCard are allso set accordingly.
    // The parameter int numPacks tells the method how many packs of cards are
    // to be added to the Deck from the masterPack.
    public void init(int numPacks)
    {
        allocateMasterPack();
        this.numPacks = numPacks;
        this.topCard = (56 * this.numPacks) - 1;

        cards = new Card[56 * numPacks];

        for (int pack = 0; pack < numPacks; pack++)
        {
            for (int card = 0; card < masterPack.length; card++)
            {
                cards[(56 * pack) + card] = masterPack[card];
            }
        }
    }

    // This public method is used to randomly shuffle the cards within a deck
    // so that all card are out of sequence.
    public void shuffle()
    {
        int split = cards.length / 2;
        Random rand = new Random();
        int shufCount = 5 * (56 * numPacks);

        do
        {
            int cardA = rand.nextInt(split);
            int cardB = rand.nextInt(split) + split;

            Card temp = cards[cardA];
            cards[cardA] = cards[cardB];
            cards[cardB] = temp;

            shufCount--;
        } while (shufCount != 0);

    }

    // A public method that returns the card on the top of the deck replacing
    // its position in the array with a null, and moving the topCard private
    // member to the next card in the deck.
    public Card dealCard()
    {
        Card retVal;
        if (topCard < 0)
        {
            retVal = new Card('B', Card.Suit.clubs);
        }
        else
        {
            retVal = cards[topCard];
            cards[topCard] = null;
            topCard--;
        }
        return retVal;
    }

    // This is an accessor method used to retreive the position of the current
    // top card in the deck array.
    public int getTopCard()
    {
        return topCard;
    }
    
    // Accessor for an individual card. 
    //Returns a card with errorFlag = true if k is bad
    public Card inspectCard(int k)
    {
        if (cards[k].getErrorFlag())
            return cards[k];
        else
            return new Card();
        
    }
    
    // This private method is used to fill the masterPack array with 52 unique
    // cards, which can than be used to populate a deck as needed. This method
    // will only run when the first deck in the program is initialized. If the
    // masterPack array is not null the method simply end makeing no changes to
    // the masterPack array.
    private static void allocateMasterPack()
    {
        if (masterPack == null)
        {
            masterPack = new Card[56];

            for (Card.Suit s : Card.Suit.values())
            {
                for (int x = 1; x < 15; x++)
                {
                    Card newCard;
                    int value = x % 15;
                    switch (value)
                    {
                        case 1:
                            newCard = new Card('A', s);
                            break;
                        case 10:
                            newCard = new Card('T', s);
                            break;
                        case 11:
                            newCard = new Card('J', s);
                            break;
                        case 12:
                            newCard = new Card('Q', s);
                            break;
                        case 13:
                            newCard = new Card('K', s);
                            break;
                        case 14:
                            newCard = new Card('X', s);
                            break;
                        default:
                            newCard = new Card(Integer.toString(value).charAt(0), s);
                    }
                    if (s == Card.Suit.clubs)
                    {
                        masterPack[x - 1] = newCard;
                    }
                    else if (s == Card.Suit.diamonds)
                    {
                        masterPack[(x - 1) + 14]
                                = newCard;
                    }
                    else if (s == Card.Suit.hearts)
                    {
                        masterPack[(x - 1) + 28]
                                = newCard;
                    }
                    else
                    {
                        masterPack[(x - 1) + 42] = newCard;
                    }
                }
            }
        }
    }
    
    //adds a card to the deck and increments topCard
    public boolean addCard( Card card )
    {
        int count = 0;
        for (int i = 0; i <= topCard; i++)
            if (cards[i].equals(card))
                count++;
        if (count > numPacks)
            return false;
        topCard++;
        cards[topCard] = card;
        return true;
    }
    
    //removes a card from the deck
    //decrements topCard
    public boolean removeCard( Card card )
    {
        for (int i = topCard; i >= 0; i--)
        {
            if (cards[i].equals(card))
            {
                if (i != topCard)
                {
                    cards[i] = cards[topCard];
                }
                cards[topCard] = null;
                topCard--;
                return true;
            }
        }
        return false;
    }
    
    //sorts the deck by suit and then value
    //calls Card's arraySort() method
    public void sort()
    {
        
        if ( this.getNumCards() != 0 )
            Card.arraySort(cards, (numPacks*56));
    }
    
    //returns number of cards in deck
    public int getNumCards()
    {
        int cardCount = 0;
        for (Card single : cards)
            if (single != null)
                cardCount++;
        return cardCount;
    }
    
}




/* ==================================================================
*
*   PROGRAM NAME:
*       Assignment5 - GUI Cards
*
*   Description:
*	Understand the Classes and Problem
*	
*	We wish to move our Card classes from the realm of console apps to 
*	that of GUI apps.  We'll do this in stages.
*	
*	>   Read and display Card pictures - Read .gif image files as Icons, 
*	and attach them to JLabels that we can display on a JFrame.
*	
*	>   Encapsulate the Card Icons in a class GUICard - Once we debug 
*	imagery for cards, above, we can move it into its own class, GUICard.
*	
*	>   Create a CardTable class - This JFrame class will embody the 
*	JPanels and Layout(s) needed for our application. This is where all 
*	the cards and controls will be placed. 
*	
*	>   Use a CardGameFramework class - Use an already created class to 
*	deal cards for display from an actual deck.
*	
*	>Create the game "High-Card"
*	
*	The first phase (item 1) will allow you to debug the problem of reading 
*	the .gif files and displaying them on a JFrame without any excess logic 
*	or class complexity.  The second phase (items 2 and 3) will let you 
*	turn what you did in the first phase into a multi-class project.  The 
*	final phase (items 4 and 5) will add the CardGameFramework class so 
*	that your card tools can be combined with your GUI tools to create a 
*	GUI program that has real computational power for a GUI card game, 
*	"High Card".
*
*   Classes:
*       None
*
*   Parameters:
*       1. none
*
*   Additional Files:
*
*   Created:
*       2017/02/01
*
*   Author/s:
*       Faiga Revah, Oswaldo Minez, Roderick Burkhardt
*
* ==================================================================*/
package assignment5;

public class CardGameFramework
{

    private static final int MAX_PLAYERS = 50;

    private int numPlayers;
    private int numPacks;            // # standard 52-card packs per deck
    // ignoring jokers or unused cards
    private int numJokersPerPack;    // if 2 per pack & 3 packs per deck, get 6
    private int numUnusedCardsPerPack;  // # cards removed from each pack
    private int numCardsPerHand;        // # cards to deal each player
    private Deck deck;               // holds the initial full deck and gets
    // smaller (usually) during play
    private Hand[] hand;             // one Hand for each player
    private Card[] unusedCardsPerPack;   // an array holding the cards not used
    // in the game.  e.g. pinochle does not
    // use cards 2-8 of any suit

    public CardGameFramework(int numPacks, int numJokersPerPack,
            int numUnusedCardsPerPack, Card[] unusedCardsPerPack,
            int numPlayers, int numCardsPerHand)
    {
        int k;

        // filter bad values
        if (numPacks < 1 || numPacks > 6)
        {
            numPacks = 1;
        }
        if (numJokersPerPack < 0 || numJokersPerPack > 4)
        {
            numJokersPerPack = 0;
        }
        if (numUnusedCardsPerPack < 0 || numUnusedCardsPerPack > 50) //  > 1 card
        {
            numUnusedCardsPerPack = 0;
        }
        if (numPlayers < 1 || numPlayers > MAX_PLAYERS)
        {
            numPlayers = 4;
        }
        // one of many ways to assure at least one full deal to all players
        if (numCardsPerHand < 1
                || numCardsPerHand > numPacks * (52 - numUnusedCardsPerPack)
                / numPlayers)
        {
            numCardsPerHand = numPacks * (52 - numUnusedCardsPerPack) / numPlayers;
        }

        // allocate
        this.unusedCardsPerPack = new Card[numUnusedCardsPerPack];
        this.hand = new Hand[numPlayers];
        for (k = 0; k < numPlayers; k++)
        {
            this.hand[k] = new Hand();
        }
        deck = new Deck(numPacks);

        // assign to members
        this.numPacks = numPacks;
        this.numJokersPerPack = numJokersPerPack;
        this.numUnusedCardsPerPack = numUnusedCardsPerPack;
        this.numPlayers = numPlayers;
        this.numCardsPerHand = numCardsPerHand;
        for (k = 0; k < numUnusedCardsPerPack; k++)
        {
            this.unusedCardsPerPack[k] = unusedCardsPerPack[k];
        }

        // prepare deck and shuffle
        newGame();
    }

    // constructor overload/default for game like bridge
    public CardGameFramework()
    {
        this(1, 0, 0, null, 4, 13);
    }

    public Hand getHand(int k)
    {
        // hands start from 0 like arrays

        // on error return automatic empty hand
        if (k < 0 || k >= numPlayers)
        {
            return new Hand();
        }

        return hand[k];
    }

    public Card getCardFromDeck()
    {
        return deck.dealCard();
    }

    public int getNumCardsRemainingInDeck()
    {
        return deck.getNumCards();
    }

    public void newGame()
    {
        int k, j;

        // clear the hands
        for (k = 0; k < numPlayers; k++)
        {
            hand[k].resetHand();
        }

        // restock the deck
        deck.init(numPacks);

        // remove unused cards
        for (k = 0; k < numUnusedCardsPerPack; k++)
        {
            deck.removeCard(unusedCardsPerPack[k]);
        }

        // add jokers
        for (k = 0; k < numPacks; k++)
        {
            for (j = 0; j < numJokersPerPack; j++)
            {
                deck.addCard(new Card('X', Card.Suit.values()[j]));
            }
        }

        // shuffle the cards
        deck.shuffle();
    }

    public boolean deal()
    {
        // returns false if not enough cards, but deals what it can
        int k, j;
        boolean enoughCards;

        // clear all hands
        for (j = 0; j < numPlayers; j++)
        {
            hand[j].resetHand();
        }

        enoughCards = true;
        for (k = 0; k < numCardsPerHand && enoughCards; k++)
        {
            for (j = 0; j < numPlayers; j++)
            {
                if (deck.getNumCards() > 0)
                {
                    hand[j].takeCard(deck.dealCard());
                }
                else
                {
                    enoughCards = false;
                    break;
                }
            }
        }

        return enoughCards;
    }

    void sortHands()
    {
        int k;

        for (k = 0; k < numPlayers; k++)
        {
            hand[k].sort();
        }
    }

    Card playCard(int playerIndex, int cardIndex)
    {
        // returns bad card if either argument is bad
        if (playerIndex < 0 || playerIndex > numPlayers - 1
                || cardIndex < 0 || cardIndex > numCardsPerHand - 1)
        {
            //Creates a card that does not work
            return new Card('M', Card.Suit.spades);
        }

        // return the card played
        return hand[playerIndex].playCard(cardIndex);

    }

    boolean takeCard(int playerIndex)
    {
        // returns false if either argument is bad
        if (playerIndex < 0 || playerIndex > numPlayers - 1)
        {
            return false;
        }

        // Are there enough Cards?
        if (deck.getNumCards() <= 0)
        {
            return false;
        }

        return hand[playerIndex].takeCard(deck.dealCard());
    }

}